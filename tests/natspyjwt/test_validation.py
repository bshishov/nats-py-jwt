import pytest

import nkeys

from natspyjwt import jwt as natsjwt
from natspyjwt.serialization import deserialize_json
from natspyjwt.models import (
    JwtHeader,
    OperatorClaims,
    AuthorizationRequestClaims,
    Import,
    Export,
    ExportType,
    UserClaims,
)
from natspyjwt.errors import JwtDecodeError, JwtInvalidClaimError, JwtInvalidHeaderError


def test_invalid_jwt_when_its_too_short() -> None:
    with pytest.raises(JwtDecodeError):
        natsjwt.decode_claims(b"123", AuthorizationRequestClaims)


def test_invalid_jwt_when_there_are_too_few_dots() -> None:
    with pytest.raises(JwtDecodeError):
        natsjwt.decode_claims(b"123.456", AuthorizationRequestClaims)


def test_invalid_jwt_no_issuer() -> None:
    p1 = b'{"typ":"JWT","alg":"ed25519-nkey"}'
    p2 = b'{"nats":{"version":2,"type":"authorization_request"}}'
    p3 = b"123"

    token = b"%s.%s.%s" % (
        natsjwt.encode_b64url_no_padding(p1),
        natsjwt.encode_b64url_no_padding(p2),
        natsjwt.encode_b64url_no_padding(p3),
    )

    with pytest.raises(JwtDecodeError):
        natsjwt.decode_claims(token, AuthorizationRequestClaims)


def test_invalid_jwt_header_parsing() -> None:
    # Create invalid JWT parts
    p1 = natsjwt.encode_b64url_no_padding(b"null")
    p2 = natsjwt.encode_b64url_no_padding(b"{}")
    p3 = natsjwt.encode_b64url_no_padding(b"[1,2,3]")
    token = b"%s.%s.%s" % (p1, p2, p3)

    with pytest.raises(JwtDecodeError) as exc_info:
        natsjwt.decode_claims(token, AuthorizationRequestClaims)
    assert str(exc_info.value) == "Can't parse JWT header"


def test_invalid_jwt_new_version() -> None:
    # Create JWT parts with version 3
    p1 = natsjwt.encode_b64url_no_padding(b'{"typ":"JWT","alg":"ed25519-nkey"}')
    p2 = natsjwt.encode_b64url_no_padding(
        b'{"nats":{"version":3,"type":"authorization_request"}}'
    )
    p3 = natsjwt.encode_b64url_no_padding(b"[1,2,3]")
    token = b"%s.%s.%s" % (p1, p2, p3)

    with pytest.raises(JwtDecodeError) as exc_info:
        natsjwt.decode_claims(token, AuthorizationRequestClaims)
    assert str(exc_info.value) == "JWT was generated by a newer version"


def test_invalid_jwt_unsupported_claim_type() -> None:
    # Create JWT parts with unsupported claim type
    p1 = natsjwt.encode_b64url_no_padding(b'{"typ":"JWT","alg":"ed25519-nkey"}')
    p2 = natsjwt.encode_b64url_no_padding(
        b'{"nats":{"version":2,"type":"non-existent"}}'
    )
    p3 = natsjwt.encode_b64url_no_padding(b"[1,2,3]")
    token = b"%s.%s.%s" % (p1, p2, p3)

    with pytest.raises(JwtDecodeError) as exc_info:
        natsjwt.decode_claims(token, AuthorizationRequestClaims)
    assert str(exc_info.value) == "Unsupported claim type non-existent"


def test_invalid_jwt_mismatch_claim_type() -> None:
    # Create JWT parts with user claim type
    p1 = natsjwt.encode_b64url_no_padding(b'{"typ":"JWT","alg":"ed25519-nkey"}')
    p2 = natsjwt.encode_b64url_no_padding(b'{"nats":{"version":2,"type":"user"}}')
    p3 = natsjwt.encode_b64url_no_padding(b"[1,2,3]")
    token = b"%s.%s.%s" % (p1, p2, p3)

    with pytest.raises(JwtDecodeError) as exc_info:
        natsjwt.decode_claims(token, AuthorizationRequestClaims)
    assert (
        str(exc_info.value)
        == "Claim type mismatch: requested AuthorizationRequestClaims but found UserClaims (for user) in JWT"
    )


def test_verify_version_1_from_type() -> None:
    # Create server key pair
    kp = nkeys.create_pair(nkeys.PrefixByte.Server)
    pk = kp.public_key()

    # Create JWT parts
    p1 = natsjwt.encode_b64url_no_padding(b'{"typ":"JWT","alg":"ed25519-nkey"}')
    p2 = natsjwt.encode_b64url_no_padding(
        f'{{"type":"authorization_request","iss":"{pk}","nats":{{}}}}'.encode("ascii")
    )

    # Sign the payload
    sig = kp.sign(p2)
    p3 = natsjwt.encode_b64url_no_padding(sig)

    # Create token
    token = b"%s.%s.%s" % (p1, p2, p3)

    # Decode and verify claims
    claims = natsjwt.decode_claims(token, AuthorizationRequestClaims)
    assert claims.iss == pk


@pytest.mark.parametrize(
    "json",
    [
        '{"type":"","iss":"@@PublicKey@@","X":{}}',
        '{"type":"","iss":"@@PublicKey@@","nats":{"X":2}}',
        '{"type":"","iss":"@@PublicKey@@","nats":{"version":2.2}}',
        '{"type":"","iss":"@@PublicKey@@","nats":{"version":2, "X":"X"}}',
        '{"type":"","iss":"@@PublicKey@@","nats":{"version":2, "type":""}}',
        '{"type":"","iss":"@@PublicKey@@","nats":{"version":2, "type":" "}}',
    ],
)
def test_verify_version_and_type_check(json: str) -> None:
    # Create server key pair
    kp = nkeys.create_pair(nkeys.PrefixByte.Server)
    pk = kp.public_key()

    # Create JWT parts
    p1 = natsjwt.encode_b64url_no_padding(b'{"typ":"JWT","alg":"ed25519-nkey"}')
    p2 = natsjwt.encode_b64url_no_padding(
        json.replace("@@PublicKey@@", pk).encode("ascii")
    )

    # Sign the payload
    sig = kp.sign(p2)
    p3 = natsjwt.encode_b64url_no_padding(sig)

    # Create token
    token = b"%s.%s.%s" % (p1, p2, p3)

    # Verify decoding fails with expected error
    with pytest.raises(JwtDecodeError):
        natsjwt.decode_claims(token, AuthorizationRequestClaims)


def test_verify_decode_encode_subject_is_not_set() -> None:
    # Create server key pair
    kp = nkeys.create_pair(nkeys.PrefixByte.Server)
    pk = kp.public_key()

    # Create JWT parts
    p1 = natsjwt.encode_b64url_no_padding(b'{"typ":"JWT","alg":"ed25519-nkey"}')
    p2 = natsjwt.encode_b64url_no_padding(
        f'{{"iss":"{pk}","nats":{{"version":2,"type":"authorization_request"}}}}'.encode(
            "ascii"
        )
    )

    # Sign the payload
    sig = kp.sign(b"%s.%s" % (p1, p2))
    p3 = natsjwt.encode_b64url_no_padding(sig)

    # Create token
    token = b"%s.%s.%s" % (p1, p2, p3)

    # Decode claims
    claims = natsjwt.decode_claims(token, AuthorizationRequestClaims)
    assert claims.iss == pk
    assert claims.nats.version == 2

    # Verify encoding fails due to missing subject
    with pytest.raises(JwtInvalidClaimError) as exc_info:
        natsjwt.encode_authorization_request_claims(claims, kp, 0)
    assert str(exc_info.value) == "Subject is not set"


@pytest.mark.parametrize(
    "typ,algo,error",
    [
        ("X", "", "Invalid JWT header: not supported type X"),
        ("JWT", "X", "Invalid JWT header: unexpected X algorithm"),
    ],
)
def test_header_validation(typ: str, algo: str, error: str) -> None:
    # Create header with specified type and algorithm
    header = JwtHeader(typ=typ, alg=algo)

    # Verify header validation fails with expected error
    with pytest.raises(JwtInvalidHeaderError) as exc_info:
        header.validate()
    assert str(exc_info.value) == error


def test_prefix_validation() -> None:
    # AccountClaims should accept Account and Operator prefixes
    assert set(natsjwt.AccountClaims().expected_prefixes()) == {
        nkeys.PrefixByte.Account,
        nkeys.PrefixByte.Operator,
    }

    # ActivationClaims should accept Account and Operator prefixes
    assert set(natsjwt.ActivationClaims().expected_prefixes()) == {
        nkeys.PrefixByte.Account,
        nkeys.PrefixByte.Operator,
    }

    # GenericClaims should accept no prefixes
    assert natsjwt.GenericClaims().expected_prefixes() == []

    # OperatorClaims should only accept Operator prefix
    assert natsjwt.OperatorClaims().expected_prefixes() == [nkeys.PrefixByte.Operator]

    # UserClaims should only accept Account prefix
    assert natsjwt.UserClaims().expected_prefixes() == [nkeys.PrefixByte.Account]

    # AuthorizationRequestClaims should only accept Server prefix
    assert natsjwt.AuthorizationRequestClaims().expected_prefixes() == [
        nkeys.PrefixByte.Server
    ]

    # AuthorizationResponseClaims should only accept Account prefix
    assert natsjwt.AuthorizationResponseClaims().expected_prefixes() == [
        nkeys.PrefixByte.Account
    ]


def test_prefix_validation_non_existent() -> None:
    # Verify that base JwtClaimsData raises error when expected_prefixes is called
    with pytest.raises(JwtInvalidClaimError) as exc_info:
        natsjwt.JwtClaimsData().expected_prefixes()
